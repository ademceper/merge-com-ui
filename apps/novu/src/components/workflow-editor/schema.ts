import { ChannelTypeEnum, type JSONSchemaDefinition, SeverityLevelEnum } from '@novu/shared';
import * as z from 'zod';

const MAX_NAME_LENGTH = 64;
const MAX_DESCRIPTION_LENGTH = 256;
const MAX_TAG_LENGTH = 32;
const MAX_TAG_ELEMENTS = 16;
const VALID_ID_REGEX = /^[a-zA-Z0-9._-]+$|^[^\s@]+@[^\s@]+\.[^\s@]+$/;

export const workflowSchema = z.object({
  active: z.boolean().optional(),
  name: z.string().min(1).max(MAX_NAME_LENGTH),
  workflowId: z.string().regex(/^[a-zA-Z0-9]+(?:[-_.][a-zA-Z0-9]+)*$/, {
    message: 'workflowId must be a valid slug format (letters, numbers, hyphens, dot and underscores only)',
  }),
  tags: z
    .array(z.string().min(0).max(MAX_TAG_LENGTH))
    .max(MAX_TAG_ELEMENTS)
    .refine((tags) => tags?.every((tag) => tag.length <= MAX_TAG_LENGTH), {
      message: `Tags must be less than ${MAX_TAG_LENGTH} characters`,
    })
    .optional()
    .refine((tags) => new Set(tags).size === tags?.length, {
      message: 'Duplicate tags are not allowed',
    }),
  description: z.string().max(MAX_DESCRIPTION_LENGTH).optional(),
  isTranslationEnabled: z.boolean().optional(),
});

export const stepSchema = z.object({
  name: z.string().min(1).max(MAX_NAME_LENGTH),
  stepId: z.string(),
});

export const buildDynamicFormSchema = ({
  to,
}: {
  to: JSONSchemaDefinition;
}): z.ZodObject<{
  to: z.ZodObject<Record<string, z.ZodType>>;
  payload: z.ZodType;
}> => {
  const properties = typeof to === 'object' ? (to.properties ?? {}) : {};
  const requiredFields = typeof to === 'object' ? (to.required ?? []) : [];
  const keys: Record<string, z.ZodType> = Object.keys(properties).reduce((acc, key) => {
    const value = properties[key];

    if (typeof value !== 'object') {
      return acc;
    }

    const isRequired = requiredFields.includes(key);
    let zodValue:
      | z.ZodString
      | z.ZodNumber
      | z.ZodOptional<z.ZodString | z.ZodNumber>
      | z.ZodEmail
      | z.ZodOptional<z.ZodEmail>;

    if (value.type === 'string') {
      if (value.format === 'email') {
        zodValue = z.email();
      } else {
        zodValue = z.string().min(1);

        if (key === 'subscriberId') {
          zodValue = zodValue.regex(
            VALID_ID_REGEX,
            'SubscriberId must be a string of alphanumeric characters, -, _, and . or a valid email address.'
          );
        }
      }
    } else {
      zodValue = z.number().min(1);
    }

    if (!isRequired) {
      zodValue = zodValue.optional();
    }

    return { ...acc, [key]: zodValue };
  }, {});

  return z.object({
    to: z.looseObject({
      ...keys,
    }),
    payload: z.string().refine(
      (str) => {
        try {
          JSON.parse(str);
          return true;
        } catch {
          return false;
        }
      },
      { message: 'Payload must be valid JSON' }
    ),
  });
};

export type TestWorkflowFormType = z.infer<ReturnType<typeof buildDynamicFormSchema>>;

const ChannelPreferenceSchema = z.object({
  enabled: z.boolean().default(true),
});

const ChannelsSchema = z.object(
  Object.fromEntries(Object.values(ChannelTypeEnum).map((channel) => [channel, ChannelPreferenceSchema]))
);

const WorkflowPreferenceSchema = z.object({
  enabled: z.boolean().default(true),
  readOnly: z.boolean().default(false),
});

const WorkflowPreferencesSchema = z.object({
  all: WorkflowPreferenceSchema,
  channels: ChannelsSchema,
});

export const UserPreferencesFormSchema = z.object({
  user: WorkflowPreferencesSchema.nullable(),
  severity: z.enum(Object.values(SeverityLevelEnum) as [string, ...string[]]).default(SeverityLevelEnum.NONE),
});
